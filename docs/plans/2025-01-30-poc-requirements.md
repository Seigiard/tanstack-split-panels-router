# POC: Двухпанельная навигация — Требования

> Status: **REQUIREMENTS**
> Date: 2025-01-30
> Ref: [Research document](./2025-01-30-multi-router-panels-research.md)
> Approach: Path D (три роутера + типизированные LinkLeft/LinkRight)
> Router: TanStack Router (но требования router-agnostic — применимы к react-router и др.)

---

## 1. Функциональные требования

### 1.1 Два взаимоисключающих режима

- **Обычный режим**: URL = pathname (`/home`, `/settings/billing`)
  - Рендерится один основной контент
  - Стандартная навигация через `<Link>`
  - Стандартный `<Outlet>` для вложенных layout-ов

- **Панельный режим**: URL = query params (`/?left=/dash&right=/route1`)
  - Рендерятся две панели (left + right) бок о бок
  - Каждая панель — независимый viewport
  - Панели могут иметь разные наборы роутов

- **Переключение**: наличие `?left=` или `?right=` в URL → панельный режим, иначе → обычный

### 1.2 Независимая навигация панелей

- Навигация в левой панели **не влияет** на правую панель и наоборот
- Каждая панель имеет своё дерево роутов
- `?left=` и `?right=` обновляются независимо

### 1.3 Вложенные роуты внутри панелей

- Панельные роуты поддерживают вложенность: parent layout → child view
- `<Outlet>` работает внутри панельных компонентов
- Пример: `/dash` рендерит `DashLayout` с `<Outlet>`, `/dash/sub1` рендерит `Sub1View` внутри этого layout-а

### 1.4 Кросс-панельная навигация

- Из компонента внутри левой панели можно навигировать правую панель
- Из компонента внутри правой панели можно навигировать левую панель
- Из любой панели можно перейти в обычный режим (pathname-навигация)

### 1.5 Deep Linking

- URL полностью описывает состояние: `/?left=/dash/sub1&right=/route2`
- Можно поделиться ссылкой — откроется то же состояние
- Обновление страницы (F5) сохраняет состояние обеих панелей

### 1.6 Browser Back/Forward

- Кнопки Back/Forward браузера корректно восстанавливают предыдущее состояние
- При переходе между панельным и обычным режимами Back/Forward работает

---

## 2. Требования к типобезопасности

### 2.1 Типизация путей навигации

- `<LinkLeft to="/dash/sub1">` — автокомплит путей левой панели
- `<LinkRight to="/route1">` — автокомплит путей правой панели
- `<LinkLeft to="/nonexistent">` — ошибка компиляции TypeScript
- `<LinkRight to="/dash/sub1">` — ошибка компиляции (это путь левой панели)

### 2.2 Типизация хуков внутри панелей

- `useParams()` внутри панельного компонента типизирован по дереву своей панели
- `useSearch()` внутри панельного компонента работает
- `useLoaderData()` (если используются loaders) типизирован

### 2.3 Стандартные роуты

- `<Link to="/home">` — стандартная типизация TanStack Router
- Обычные роуты не затронуты панельной архитектурой

---

## 3. Требования к DX (Developer Experience)

### 3.1 Добавление нового панельного роута

Разработчик должен:
1. Добавить `createRoute(...)` в дерево панели
2. Всё — типы, навигация, рендеринг подхватятся автоматически

Разработчик **не должен**:
- Вручную обновлять реестр / routeMap
- Писать отдельную типизацию для нового роута
- Модифицировать компоненты навигации

### 3.2 Написание панельного компонента

- Панельный компонент пишется **так же**, как обычный route component
- `<Outlet>` для вложенности — стандартный
- `useParams()`, `useSearch()` — стандартные
- Единственное отличие: для кросс-панельной навигации используется `<LinkLeft>` / `<LinkRight>` вместо `<Link>`

### 3.3 Единообразие API

- Панельные роуты объявляются через `createRoute` — как обычные
- Layout-ы с `<Outlet>` — как обычные
- Error boundaries — как обычные
- Loaders (если нужны) — как обычные

---

## 4. Требования к URL-формату

### 4.1 Обычный режим

```
/home
/settings
/settings/billing
```

### 4.2 Панельный режим

```
/?left=/dash&right=/route1
/?left=/dash/sub1&right=/route2
```

### 4.3 Переходы между режимами

```
/home → /?left=/dash&right=/route1     (вход в панельный режим)
/?left=/dash&right=/route1 → /home     (выход из панельного режима)
```

### 4.4 Чистые пути

- Пути в query params не содержат служебных префиксов
- `?left=/dash/sub1` — не `?left=/leftPanel/dash/sub1`
- Пользователь видит осмысленные пути

---

## 5. Требования к рендерингу

### 5.1 Обычный режим

```
<AppShell>
  <Outlet />           ← стандартный matched route
</AppShell>
```

### 5.2 Панельный режим

```
<AppShell>
  <PanelShell>
    <LeftPanel>
      <RouterProvider router={leftRouter}>
        <LeftPanelLayout>
          <Outlet />   ← matched panel route с вложенностью
        </LeftPanelLayout>
      </RouterProvider>
    </LeftPanel>
    <RightPanel>
      <RouterProvider router={rightRouter}>
        ...
      </RouterProvider>
    </RightPanel>
  </PanelShell>
</AppShell>
```

### 5.3 Переключение режимов

- При переходе из обычного в панельный режим — анмаунт основного контента, маунт PanelShell
- При переходе из панельного в обычный — анмаунт PanelShell, маунт основного контента
- Переход должен быть без flash of wrong content

---

## 6. Edge Cases для проверки в POC

### 6.1 Инициализация

- [ ] Открытие `/?left=/dash/sub1&right=/route2` напрямую (deep link)
- [ ] Открытие `/?left=/dash` (только одна панель указана, right = default)
- [ ] Открытие `/?left=/nonexistent&right=/route1` (невалидный путь)
- [ ] Открытие `/` без параметров (обычный режим)

### 6.2 Навигация

- [ ] Клик внутри левой панели — обновляет только `?left=`
- [ ] Клик внутри правой панели — обновляет только `?right=`
- [ ] Кросс-навигация: из левой панели открыть что-то в правой
- [ ] Выход из панельного режима (навигация на `/home`)
- [ ] Вход в панельный режим из обычного

### 6.3 Browser History

- [ ] Back после навигации внутри левой панели
- [ ] Back после навигации внутри правой панели
- [ ] Back из панельного режима в обычный
- [ ] Forward обратно в панельный режим
- [ ] Быстрые последовательные клики (race condition)

### 6.4 Вложенность

- [ ] Parent layout + child view через `<Outlet>`
- [ ] Переход между sibling routes внутри панели (`/dash/sub1` → `/dash/sub2`)
- [ ] Переход с child на parent (`/dash/sub1` → `/dash`)
- [ ] `useParams()` в child route содержит правильные параметры

### 6.5 Граничные случаи

- [ ] Обе панели на одном и том же роуте (если допустимо)
- [ ] F5 (refresh) в панельном режиме
- [ ] Прямой ввод URL в адресную строку
- [ ] Несколько быстрых переходов между режимами

---

## 7. Минимальный набор роутов для POC

### Main (обычные)

```
/home          → HomeView
/settings      → SettingsLayout + <Outlet>
/settings/billing → BillingView
```

### Left Panel

```
/dash          → DashLayout + <Outlet>
/dash/sub1     → Sub1View
/dash/sub2     → Sub2View
```

### Right Panel

```
/route1        → Route1View
/route2        → Route2View
```

### Компоненты для POC

Минимальные — достаточно отображать:
- Имя текущего роута
- Кнопки навигации внутри панели
- Кнопку кросс-панельной навигации
- Кнопку выхода из панельного режима
- Для DashLayout — `<Outlet>` с визуальным обрамлением

---

## 8. Критерии успеха POC

POC считается **успешным**, если:

1. ✅ Все edge cases из секции 6 пройдены
2. ✅ `<LinkLeft to="...">` и `<LinkRight to="...">` дают автокомплит в IDE
3. ✅ Невалидные пути вызывают ошибку TypeScript
4. ✅ `<Outlet>` работает внутри панельных layout-ов
5. ✅ `useParams()` типизирован внутри панельных компонентов
6. ✅ Browser Back/Forward работает корректно
7. ✅ Deep linking работает (F5, share URL)
8. ✅ Нет flash of wrong content при инициализации

POC считается **провалом**, если:

1. ❌ `<Outlet>` не работает внутри панелей
2. ❌ Типизация не выводится из route tree (приходится дублировать вручную)
3. ❌ Browser history ломается (Back/Forward не восстанавливают состояние)
4. ❌ Race conditions при быстрых кликах
5. ❌ Невозможно сделать кросс-панельную навигацию из компонента

---

## 9. Router-Agnostic Notes

Эти требования **не привязаны к TanStack Router**. При попытке реализации
на другом роутере (react-router, wouter, и т.д.) нужно проверить:

| Capability | TanStack Router | react-router | Нужно для POC |
|------------|:---:|:---:|:---:|
| Custom history | ✅ RouterHistory | ✅ createMemoryRouter | да |
| Multiple RouterProvider | ✅ (с caveats) | ✅ RouterProvider | да |
| Type-safe route paths | ✅ RoutePaths<T> | ❌ (нет вывода типов) | да |
| Nested Outlet | ✅ | ✅ | да |
| useParams typed | ✅ | ⚠️ (generic) | да |
| Route loaders | ✅ | ✅ | nice-to-have |
| Search params validation | ✅ validateSearch | ❌ (manual) | да |

> **Вывод**: react-router не даёт типобезопасность из route tree.
> Если переходить на react-router, потребуется ручная типизация путей
> (const array as const + typeof) вместо `RoutePaths<T>`.
